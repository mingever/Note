## 简介

### 特点

**1）面对对象**

面对对象的四个基本特征

1. 抽象：将现实世界的事物描述为系统中类，对象，方法的过程

2. 继承：实现==软件复用==的重要手段

3. 封装：将对象的==实现细节隐藏==起来，只提供一些==公共的方法==将对象的功能展现出来

4. 多态：多态指==子类对象可以直接赋值给父类变量==，但在==运行时依然表现出子类的特征==

	java引用变量有两种类型：编译时类型和运行时类型。==编译时类型由声明类型决定==，==运行时类型由赋值对象的类型决定==，两者类型不一致时就会出现多态。

**2）跨平台**

通过JVM(java虚拟机)实现跨平台。

java源代码（.java）经过java编译器编译成java字节码（.class）字节码经过jvm的解释变为指令。
java是一种半编译半解释执行的语言。预编译+解释器+即时编译（JIT）也就是所谓的虚拟机形式（这种在运行过程中进行编译的方式叫做JIT）。

java是跨平台的，==jvm不是跨平台的==。

一个java文件如果有多个类，只允许有一个类用public修饰，因为如果用public修饰，那么文件名必须与类名相同，如果用只class声明，此时文件名和类名可以不相同

不管在不在一个java文件中，项目经编译后，有几个类就会在bin文件夹下生成几个.class字节码文件

**3）静态语言**

静态语言指的就是在==编译期间就能够知道数据类型==的语言，在==运行前就能够检查类型的正确性==，一旦==类型确定后就不能再更改==

动态语言没有任何特定的情况需要指定变量的类型，==在运行时确定的数据类型==。比如==Python==、Ruby、JavaScript 等

### jdk

java软件开发工具包，包括：

1. development tools

2. jre：java运行时环境，包括：

	1. java SE API：java系统核心类库

	1. jvm：java虚拟机

### 常用类和方法

#### lang包

1. java.lang.*; 包是默认导入的，不需要手动import

2. 是java语言的核心，提供了java中的基础类
	- 类型：Object类，Class类，String类，基本类型，包装类
	- 工具：数学类Math；安全；注解Override
	- 系统：Syetem类；进程；线程Thread；运行Runnable；堆栈；异常Throwable类

#### System类

1. 代表系统，构造方法是private所以无法创建对象，其内部的成员方法和成员变量是static的

2. in，out，err 三个成员变量，分别为标准输入流，标准输出流，标准错误流。out可以调用printStream中的方法，如`System.out.println`

3. `System.in`标准输入流，是很原始，很简陋的输入流对象，属于字节流，通常不会直接读取用户的属于，一般会在外面包装过滤流

    ``` java
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    String srt = br.readLine();
    ```

4. System中的常用方法
	- `System.arraycopy()`：复制数组
	- gc：垃圾回收器，自动调用
	- exit(int i)：退出虚拟机，非0表示异常终止，0表示终止，如System.exit(0);退出程序。即该方法永远不会正常返回，唯一一个退出程序而不执行finally

#### Scanner类

- 用于扫描输入文本的新的实用程序，可获取用户的输入
- 不同的构造器可以接受从文件、输入流、字符串作为数据源，用于从文件、输入流和字符串中解析数据
- next()：获得输入的字符串，遇到第一个有效字符时开始扫描，当遇到第一个空格或换行符时，结束扫描。即字符串不能包括空格，遇到空格即扫描结束。
- nextLine()：可以扫描一行内容并作为一个字符串而被获取到。即可以将空格看出字符串的一部分，以换行符（Enteer）作为结束符
- hasNext()：把输入的值存入到scanner中，然后返回一个boolean类型，经常使用其判断是否还有输入
- hasNextLine()：和haxNext的关系与next和nextLine的关系类似
- nextInt()：只能输入int类型的数据

#### Math类

里面都是静态方法

- long round(double d)：四舍五入
- double ceil(double     d)：向上取整，即不小于它的最小整数
- double abs(double d)：取绝对值

#### 随机数

1. **Random类**

	- `int i = random.nexInt();` 随机生成一个int整数，范围在 -2^31~2^31-1
		
	- `int i = random.nexInt(n);` 获取[0,n)之间的int整数
		
	- `int i = random.nextInt(m-n+1)+n;` 生成[n,m]之间的随机整数

		```java
		Random random = new Random();
		
		int i = random.nexInt(101);           获取[0,100]之间的整数
		int i = random.nextInt(26)+65;        获取[65,90]之间的整数
		```


2. **Math.random()方法**

	- 返回值为double类型，范围在[0.0-1.0)
		
	- `int i = (int)(Math.random()*(m-n+1)+n)`：生成[n,m]之间的随机整
	
		```java
		int i = (int)(Math.random()*100+1);     //生成[1,100]之间的随机整数
		```




## 语法

### 数据类型

#### 表达式和直接量

1. 表达式：表达式就是符号（如加号，等号）与操作数（如b，3）的组合

2. 直接量：在程序中通过源代码直接给出的值，有以下类型

	- 基本类型

		- int:整数的默认类型

		- long:整型数值后添加L

		- float:在一个浮点数后面加

		- double:浮点数的默认类型

		- boolean:只有true和false

		- char:三种 单引号括起来的一个字符，转义字符，和Unicode值 如，'a'，'\n'，'\u0061'

	- 字符串类型

	    用双引号括起来的字符就是String类型的直接量，如"abc"

	- null

		是一种特殊类型，只有一个值null，而且他可以赋给任何引用类型的变量，用以表示这个引用类型变量中保存的地址为null



#### 基本类型

**1）字节型**

byte：==1字节==（8位）

**2）整型**

1. short：2字节

2. int：存储普通整数，==4个字节==（32位）

	  - ==整数的直接量默认类型为int类型==


	  - 两个整数相除，不会四舍五入，会==舍去小数部分==。


	  - 如果除法运算符的两个运算数都是整数，则除数不可以为0，否则会引发除零异常。


	  - 如果除法运算法的两个运算数有1个浮点数，或者有两个浮点数，则运算结果也是浮点数。
		而且此时允许除数为0、或者除数为0.0，得到的结果将是正无穷大(Infinity)或者负无穷大(-Infinity)

3. long：存储长整数，==8个字节==

	如果要表示==long直接量要以l或者L结尾==，如`long b=1000000000L`

**3）浮点型**

用来存储长精度浮点数，即小数。大多数使用double类型

1. float

	java中==小数直接量是double==，==表示float类型的直接量要加f或者F==，如``float f = 3.1f ``

2. double：8字节

	不要使用浮点型来进行运算，会有精度问题，要使用`BigDecimal`如

	```java
	System.out.println(0.05+0.01);
	System.out.println(1.0-0.42);
	System.out.println(4.015*100);
	System.out.println(123.3/100);
	System.out.println(0.1*3);
	结果是
	0.060000000000000005
	0.5800000000000001
	401.49999999999994
	1.2329999999999999
	0.30000000000000004
	```

**4）字符型**

char：2字节

存储一个字符本质是一个==16位无符号整数==，这个值对应字符的编码。java字符类型采用==Unicode字符编码集==，是通用的定长字符集，==所有字符都是16位，可以存储一个汉字==

- 对char类型变量赋值

	1. 字符直接量：如'A',变量中实际存储的是该字符的编码，一个char型变量只能存储一个字符

		A：65，a：97

	2. 整型直接量：范围0~65535直接的整数

	3. Unicode形式：'\u0041'十六进制形式

- =='A'+10：为int类型==，`(char)('A'+10)`：==强制转化为char型==

**5）布尔型**

boolean

适用于逻辑运算，一般用于程序的流程控制，值能取值true或false，经常存储关系运算的结果



#### 引用类型

也叫复合类型

本质是指针，从栈内存里指向堆内存里的一个地址，固定用==4个字节==来表示，一般都可以用new来创建

- 数组
- 类：是一种超复杂的数据类型
- 接口
- 字符串



#### 基本类型之间的转换

**1）赋值语句时**

1. 自动类型转换

	- 从==小类型到大类型==可以自动完成 char->int->long->float->doubl

		```java
		int a=100;
		double b=a; //a自动转化为double型
		```

	- 如果一个操作数为double型，则整个表达式可提升为double型

		```java
		double a=100;
		double b;
		int c =100;
		b = a+c;
		//b为double，a+b结果为double型，这时c自动转化为double型，然后与a相加
		```

	- 满足自动转换的条件

		- 两者==类型要兼容==：==数值类型（整型和浮点型）互相兼容==
		- ==目标类型大于源类型==


2. 强制类型转换

	语法：`(需要转换的数据类型)变量;`

	不能从大类型自动转换为小类型，要强制数据类型转换，但会造成溢出值变为0或者造成==精度损失==

**2）表达式时**

1. 自动转换

  ==多种基本类型参与的表达式中，运算结果往往会自动的向较大类型转换==

   ``` java
   double a = 80/100;
   //结果为0.0，80和100直接量为int，两个int相除结果舍去小数为0，a为double型，结果自动转化为double型0.0
   double b = 80.0/100
   //结果为0.8，80.0的直接量为double，100自动转化为double型，两double型相除
   ```

2. byte,char,short 转换为int

  这三种类型==实际存储的都是整数==

  - int直接量可以直接赋值给byte,char,short只要不超过其表示范围

  - ==byte,char,short参与运算时，先将其全部转化为int型再做运算==，==即byte+byte为int型==

  	```java
  	byte a=1;
  	byte b=2;
  	byte c=a+b;//错误，a+b为int型，无法给byte型，
  	byte c=(byte)(a+b);// 要强制类型转换
  	```



### 变量

==变量的操作必须与数据类型相匹配，注意强制类型转换==

#### 变量类型

1. 局部变量

	定义在方法内或语句块内，从属于方法或语句块使用之前，必须手动初始化。
	即，==是没有初始值的，必须手动赋值==

2. 成员变量（实例变量）

	定义在类内，方法外，从属于对象

	==如果没有手动初始化，系统会自动初始化，有默认值==，int-0，double-0.0，boolean-false，char-\u000，引用类型-null

3. 静态变量（类变量）

	定义在类内，方法外，使用static修饰，从属于类

	==如果没有手动初始化，系统会自动初始化，有默认值==，int-0，double-0.0，boolean-false，char-\u000，引用类型-null

	对所有对象共享，==先加载静态，后有对象==

	==只能修饰成员对象==

#### 声明变量

`数据类型名 变量名;`

即，在内存中开辟一个来存储该数据类型的空间

命名规则：

1. 必须以字母 下滑线“_”，或“$”符号开头
2. 可以包括数字，但不能以数字开头
3. 除了“_”和“$”不能包含任何特殊字符
4. 不能使用java语言的关建字，如int,class,public
5. 区分大小写，java对大小写敏感

#### 变量的访问

==变量必须声明和初始化（即赋值）之后才可以使用==

使用变量就是在使用变量对应的内存空间的中存储的数据

#### 变量的作用域

从声明的地方开始到快要结束时为止，只在声明的代码块中有效

#### 内存分配

1. 在类中声明的变量，即==成员变量==，==不管是基本类型还是引用类型都放在堆中==

	  - 声明的是基本类型的变量,其变量名及其值放在堆内存中
	- 声明的是引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中

2. 如果是方法中声明的变量、方法的形参，==即局部变量==。每当程序调用方法时，系统都会为该方法建立一个==方法栈==，其所在方法中声明的变量就放在方法栈中，==当方法结束系统会释放方法栈==，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。

	  - 声明是==基本类型==的变量的时，其==变量名及值（变量名及值是两个概念）是放在方法栈中==
	- 当声明的是==引用变量==时，所声明的==变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中==，该==变量所指向的对象是放在堆类存中的==

3. 在java里面==通过new出来的对象都在堆上分配==，这里有两种特殊情况

	  - ==字符串的字面量==：没有new关键字，但却是在堆上分配内存的，严格的说是在==堆里面的字符串常量池里面==。
- 基本类型的==包装类==

***

除了基本类型之外的，其他的所有类型，String、数组、枚举都是引用类型，变量中保存的是实际对象在堆内存中的地址

- 基本类型和引用类型

  int num = 10;

  String str = "hello";

  num 是基本类型，值就直接保存在变量中。

  str 是引用类型，变量中保存的只是实际对象的地址。一般称这种变量为"引用"，引用指向实际对象，实际对象中保存着内容。

  <img src="https://oss.mingever.com/note/java/variable1.png" style="zoom:50%;" />

- 赋值运算符（=）

	num = 20;

	str = "java";

	对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。

	对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉，但是原来的对象不会被改变。如"hello"     字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被gc回收）

	<img src="https://oss.mingever.com/note/java/variable2.png" style="zoom:50%;" />



### 运算符

#### 赋值运算符

`=`

#### 算数运算符

`+ - * /`

`% `取余：%与后面的数的正负没有关系，与前面数的正负有关系

`++ `自增  `--`自减

​	++a：:先使用，再a=a+1

​	a++：先a=a+1，再使用

#### 关系运算符

`>  >=  <  <=  ==  !=`

用于比较两个数值的大小，==结果是一个boolean值==，一般用于流程控制 

- 如果进行比较的两个操作数都是数值型，即使他们的数据类型不同，只要他们的值相等，都返回true
- 如果两个操作数都是引用类型，那么只有当两个引用变量引用相同类的实例才可以比较，而且这两个引用必须指向同一个对象才会返回true
- 基本类型的变量和值不能用==与引用型的变量和值进行比较
- boolean型的变量值不能使用==与其他任意类型的变量和值进行比较

#### 逻辑运算符

用于两个布尔型的变量或者常量的运算

&&与||总是会先计算左边的操作数，如果发生了短路，第二个操作数没有机会执行
而&和|不会有短路效果，总是会计算前后两个操作数

`&& `与

`& ` 不短路与

`||`  或

`|`    不短路或

`!`    非 只需要一个操作数

`^ `     异或，当==两个操作数不同时返回true，否则返回false==

#### 位运算符

针对两个二进制数的位进行逻辑运算

`&`  按位与     两个操作数中 位都是1，结果才是1，或则为0

`| `  按位或      两个位只有一个为1，那么结果就是1，否则为0

`~`  按位非     如果位为0，结果是1； 如果位为1，结果为0

`^`  按位异或   相同则结果为0，不同则结果为1

`<<`  左移     将运算符左边的对象，按右边指定的位数向左移动运算符，并且在低位补0 ，向左移动n位就相当于乘以2^n^

`>>` 右移      带符号的右移运算符，将运算符左边的对象，按右边指定的位数向右移动运算符，如果是正数，则在高位 补0；如果是负数，则在高位补1

`>>> `无符号右移   将运算符左边的对象，按右边指定 的位数向右移动运算符，并且在高位补0，其实向右移动n位就相当于除以2^n^

#### 条件运算符（三目运算符）

`boolean表达式?表达式1:表达式2;`



#### 运算符优先级

java大部分运算是从左至右，只有==单目运算符==（++ -- ！等只有一个运算数的），==赋值运算符==，==三目运算符==是右结合性

==单目乘除为关系，逻辑三目后赋值==

| 优先级 | 名称           | 运算符              | 结合性 |
| ------ | -------------- | ------------------- | ------ |
| 1      | 分隔符         | （） []    .   ， ; |        |
| 2      | 单目运算符     | ++ -- !             | 右结合 |
| 3      | 强制类型转换   | （type）            |        |
| 4      | 乘法 除法 求余 | / * %               |        |
| 5      | 加法 减法      | +  -                |        |
| 6      | 移位运算符     | << >>   >>>         |        |
| 7      | 关系运算符     | <  >    <=  >=      |        |
| 8      | 等价运算符     | ==  !=              |        |
| 9      | 按位与         | &                   |        |
| 10     | 按位异或       | ^                   |        |
| 11     | 按位或         | \|                  |        |
| 12     | 与             | &&                  |        |
| 13     | 或             | \|\|                |        |
| 14     | 三目运算符     | ?:                  | 右结合 |
| 15     | 赋值运算符     | = +=   -=  *=       | 右结合 |



### 数组

- 数组是最常见的一种==数据结构==，是由相同数据类型的数组元素组成的集合，元素按照线性顺序排列。
- 数据结构：计算机存储，组织数据的方式。就是把数据按照某种特定的结构来保存
- 数组也是一种数据类型，本身==是一种引用类型==，如int是一个基本类型，但int[]是一种引用类型
- 数组是一种引用类型的变量，使用他==定义一个数组变量时，仅仅表示定义了一个引用变量（即定义了一个指针），这个引用变量未指向任何有效的内存空间，因此定义数组时不能指定数组的长度。只有初始化后才指向了一个内存空间，即数组只有初始化后才能使用==

#### 数组的定义

`int[] arrayName;`

变量名为arrayName，==变量类型为int[]==为引用类型



#### 数组的初始化

**1）静态初始化：由自己指定每个数组元素的初始值，由系统决定数组长度**

`arrayName = new type[]{element1,element2,…..};`

- 定义和初始化同时完成：`type[] arrauName = new type[]{element1,element2,…..};`

- 简化：`type[] arryName={element1,element2,…..};`  ==定义和初始化必须同时完成，才能用这种形式，类似String==

- 数组元素的值的类型必须与new关键字后的type类型相同，或者是其子类的实例，如

	``` java
	Object[] objArr;
	objarr=new String[] {"java","tom"};  //String类型是Object类型的子类，子类实例是一种特殊的父类实例
	```

**2）动态初始化：只指定数组的长度，由系统为每个数组元素指定初始值**

`arrayname=new type[length];`

- 定义和初始化同时完成：`type[] arrayName=new type[length];`

- 需指定一个int型的length参数来指定数组的长度，即为每个数组元素指定所需的内存空间，系统分配初始值 0,0.0,“/u000”,false

> 注意：int[] a = new int[10] 10并不是下标，而是长度；下标从0开始，最后一个为a[9]



#### 数组的访问

数组初始化完成后即可使用，如赋值，访问元素值，获得数组长度

1. 获取数组长度:==length属性==
2. 通过下标访问数组：`for(int i=0;i<arr.length;i++) arr[i]`  注意下标不能大于或等于数组长度，否则会报数组下标越界异常



#### 数组的复制

- 手动复制：新建数组实例，在类型和空间大小上必须与原数组完全相同

- System.arraycopy方法：`System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length);`  

	​	src：源数组

	​	srcPos：源数组中的起始位置，位置从下标0开始

	​	dest：目标数组

	​	destPos：目标数组中的起始位置

	​	lenght：要赋值数组元素的个数

- Arrays.copyOf方法：`type[] newArrays = Arrays.copyOf(type[] original,int newLength);`

	​	生产的新数组是原始数组的副本，如果newLength小于原数组，则进行截取；如果大于原数组，则用0或null填充

- ==一个数组直接赋值给另一个数组==也是允许的。获取的是其引用，它们==指向同一块内存==



#### 数组的扩容

==数组定义好了之后，长度不能再改变==，只能创建一个更大的数组，将原数组复制到其中



#### 二维数组

二维数组是一维数组的数组

``` java
int[] [] a = new int[3] [4] //三行四列

int[] [] a = new int[3] []
a[0] = new int[3];  //a[0]即相当于一维数组名
a[1] = new int[4];
a[2] = new int[2];
a.length=3;
a[0].length=3;
a[1].length=4;

int[] [] a = new int[] []{{1,2},{3,4}};
int[] [] a = {{1,2},{3,4}}
```



## 程序结构

程序只有顺序，选择，循环三种结构构成

### 顺序结构

顺序结构的程序设计是最简单的，只要按照解决问题的顺序写出相应的语句就行，他的执行顺序是自上而下，依次执行

### 选择结构

#### if条件结构

``` java
if(条件){
	代码块;
}
```

#### if-else结构

``` java
if(条件){
    代码块1;
}else{
    代码块2;
}
```

#### 多重if条件结构

解决需要判断的条件是连续的区间

else块最多有一个或者没有，else块必须放在else if之后

else if块的顺序是连续的，而不是跳跃的，因为第一个条件之后的所有条件都是在第一个条件补成立的条件下才出现的，依次类推

``` java
if(条件){
    代码块1;
}else if(条件2){
    代码块2;
}else{
    代码块3;
}
```

#### 嵌套if条件结构

只有当满足外层if条件时，才会判断内层if的条件

else总是与他前面最近的那个缺少else的if配对

``` java
if(条件1){
    if(条件2){
        代码块1;
    }else{
        代码块2;
    }
}else{
    代码块3;
}
```

#### swith

由一个控制表达式和多个case标签组成，==控制表达式的数据类型只能是byte，short，char，int和枚举类型，后加入了String类型，不能是boolean类型==

==表达式的值类型必须和case值类型一致==，需要在case标签后紧跟一个代码块，case标签作为这个代码块的标志

先对表达式求值，然后依次匹配：常量1，常量2,…..遇到匹配的值即执行相应的代码块，如果与case后的值都不与表达式的值相等，则执行defaul标签后的代码块

==必须有break，才能跳出switch语句，否则会顺序执行==

default是可选项；位置不是固定的，但习惯放在最后，是最后执行的

``` java
switch(表达式){
case 常量1:
       代码块1
       beak;
...
default:
    代码块n;
}
```



### 循环结构

1. 循环的要素

  1. 循环条件：是一个boolean表达式，决定是否执行循环体

  2. 循环体：是循环的主体，如果代码块只有一句，可以省略括号

2. 三种循环结构来完成循环控制

	- for循环：对于循环次数已知的循环

	- while循环：控制循环次数未知的循环

	- do-while循环：用来完成至少需要一次的循环

#### while循环

每次执行循环体之前，先判断循环条件是否成立，如果循环条件成立，即为true，则执行循环体部分。执行完循环体之后，再一次判断循环体是否成立，直到循环不成立，即为false时，循环体中的语句块不会被执行，执行循环后面的语句。

要保证循环条件有变为false的情况，否则，这个循环将成为死循环

while(表达式);  如果后面跟了个;一个单独的分号表示一个空语句，表示循环体为空语句，变为死循环

``` java
while(boolean表达式){
    语句块;
}
```

#### do-while循环

do-while循环的循环条件后面要有一个分号“;”表示循环结束

即使循环条件的值开始就为假，也会执行一次循环体

先执行循环体，然后才判断循环条件。而while循环为先判断循环条件，再执行循环体

``` java
do{
    语句块；
}while(条件表达式);     //千万别忘记;
```

#### for循环

``` java
for(表达式1;表达式2;表示式3){
    循环体;
}
```

| 表达式  | 形式                   | 功能                                         | 举例     |
| ------- | ---------------------- | -------------------------------------------- | -------- |
| 表达式1 | 赋值语句               | 循环结构的初始部分，为循环变量赋初值         | int i=0; |
| 表达式2 | 条件语句               | 循环结构的循环条件                           | i<100;   |
| 表达式3 | 赋值语句，通常为++或-- | 循环结构的迭代部分，通常用来修改循环变量的值 | i++;     |

表达式1为初始部分，只执行一次，用来记录循环次数；然后判断循环条件，如果为true则执行一次循环体，循环体结束后，执行迭代部分，然后再判断循环条件，如果仍为true，继续执行循环体，迭代部分。直到循环条件为假，退出循环。表达式1只执行一次，表达式2和表达式3则可能执行很多次；循环体可能多次执行也可能一次都不执行

表达式1可以省略，如下，但==要注意变量的作用域==，在for循环里的变量只在该循环体里有效，如for(int i=0;i<10;i++) i的作用域为该循环

``` java
int i=0;
for(;i<10;i++)
```

#### break

==强行终止循环，跳出循环体，跳出最里面的循环，经常与if条件语句一起使用==

#### continue

==只是终止本次循环，接着开始下一次循环，只能用于循环结构之中==

1. ==在 for 循环中，continue 语句使程序立即跳转到迭代部分。==

2. ==在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。==



## 方法

方法用于封装一段特定的逻辑功能，便于维护

### 方法的定义

``` java
[修饰符] 返回值类型 方法名(形参){
	方法体
	return 返回值
}
```

1. ==五个要素：修饰符，返回值类型，方法名，参数列表，方法体==

2. 修饰符不是方法必须的

3. ==方法在声明时必须指定返回值类型==，若方法不需要返回数据，将返回值类型声明为void；若方法返回数据，将返回值类型声明为特定数据类型

4. ==若想在main方法中直接调用方法，则方法必须声明为static==

5. ==定义方法要考虑方法的返回类型和方法的返回参数；要明确定义的功能最后的结果是什么，明确是否需要未知参数与运算。==

6. 通过retutn语句返回，==return作用在于结束方法且将数据返回给调用方==，==也可以在无返回值中使用return关键字==

	``` java
	//使用无返回值 return; 如果使用break，会多打印一句，因此使用return，直接结束函数
	public static void print42(int[] numbers) {
	    for(int i=0; i<numbers.length; i++) {
	        if (numbers[i] == 42) {
	            System.out.println("has 42");
	            return;
	        }
	    }
	    System.out.println("no 42");
	}
	```



### 形参和实参

- 形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了

- 实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。

- ==形参和实参是两个独立的内存空间==，并不是一个；==向形参传递的也只是实参内容拷贝的副本==

	

### 可变参数

Java5引入，允许在调用方法时传入不定长度的参数，本质上是基于数组来实现的，属于语法糖

**1）语法**

在定义方法时，在最后一个形参后加上三点 …，就表示该形参可以接受多个参数值，多个参数值==被当成数组==传入

`void foo(String... args);`  就相当于：void foo(String[] args);

- ==可变参数只能作为函数的最后一个参数==，但其前面可以有也可以没有任何其他参数

- 由于可变参数必须是最后一个参数，所以一个函数==最多只能有一个可变参数==

- Java的可变参数，会==被编译器转型为一个数组==

- 变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立

	``` java
	public void foo(String...varargs){}
	foo("arg1", "arg2", "arg3");
	
	//上述过程和下面的调用是等价的
	foo(new String[]{"arg1", "arg2", "arg3"});
	
	```

**2）示例**

``` java
public class Test {
    public static void main(String[] args) {
        System.out.println(sum(2,3,5,1,6));
    }

    //求和，其参数本质上为一个int[] a
    public static int sum(int... a){
        int sum=0;
        for (int i : a) {
            sum+=i;
        }
        return sum;
    }
}
```



### 方法的调用

程序执行的入口是从主方法开始，一行一行的执行，自定义方法需要主方法的调用才会执行

1. 语法格式：`方法名([参数]);`
	- 静态方法：`类名.静态方法名();`
	- 非静态方法：先实例化对象，然后`对象名.非静态方法名();`

2. 注意
	- 方法被调用时，传给被调用方法的==实参类型需要和方法定义的形参类型匹配==
	- 方法调用语句所处的上下文环境==要和方法定义的返回值类型匹配==
	- ==主方法是staitc修饰的==，如果==在主方法中直接调用自定义方法，该方法需要关键字static修饰==



### 方法调用分析

#### 过程分析

1. 系统会在栈内存中为方法的局部变量（形参也属于局部变量）分配临时空间，即==局部变量只有在方法被调用时才会在栈上分配临时空间==
2. 将实参的值传给形参
3. 程序流程跳转到被调用的方法中执行
4. 被调用方法执行完成或遇到return时，流程跳回到主调用方法，并将return后的值带回主调用方法
5. 被调用方法的临时空间释放，流程从主调用方法中继续向下执行

#### 内存分析

==java中方法参数传递方式是按值传递==

1. 如果参数是==基本类型==，传递的是==基本类型的字面量值的拷贝。==
2. 如果参数是==引用类型==，传递的是==该参数所引用的对象在堆中地址值的拷贝==，即传值的方式传地址
3. Java 只有值传递参数。当一个==对象==实例作为一个参数被传递到方法中时，参数的值就是==该对象引用的一个副本==。形参和实参指向同一个对象,对象的内容可以在被调用的方法中改变，但实参对象的引用（不是引用的副本）是不会改变的。即传递参数是引用类型，并不代表就是引用传递，其实它还是值传递



### 值传递

java中方法参数传递方式是按值传递。

- 如果参数是==基本类型==，传递的是==基本类型的字面量值的拷贝==。
- 如果参数是==引用类型==，传递的是==该参数所引用的对象在堆中地址值的拷贝==，即传值的方式传地址
- Java 只有值传递参数。当一个==对象实例==作为一个参数被传递到方法中时，参数的值就是==该对象引用的一个副本==。形参和实参指向同一个对象,对象的内容可以在被调用的方法中改变，但实参对象的引用（不是引用的副本）是不会改变的。即传递参数是引用类型，并不代表就是引用传递，其实它还是值传递

1. 例1

	``` java
	public class Test {
	    public static void main(String[] args) {
	        int num = 5;
	        System.out.println(num);
	        change(num);
	        System.out.println(num);
	    }
	
	    public static void change(int num){
	        num = num*2;
	    }
	}
	
	```

	当调用change方法时，会在栈上为形参num分配一个临时空间
	实参num的值并不会被改变，在函数中修改的仅仅是形参，对实参的值的没有影响。
	相当于是把实参num的值“5”，拷贝了一份传给了形参num，操作形参num的存储空间，并不会影响到实参num

	<img src="https://oss.mingever.com/note/java/PassByValue1.png" style="zoom: 67%;" />

2. 例2

	``` java
	public class Test {
	    int num =5;
	    public static void main(String[] args) {
	        Test test = new Test();
	        System.out.println(test.num);
	        change(test);
	        System.out.println(test.num);
	    }
	
	    public static void change(Test test){
	        test.num=10;
	    }
	}
	```

	传递的是实参test所引用的对象在堆内存中地址值的拷贝，传递给了形参test。
	他们实际上是指向了堆内存中的同一个Test对象，因此change方法对形参test对象内容的修改也会体现到实参test上

	<img src="https://oss.mingever.com/note/java/PassByValue2.png" style="zoom: 67%;" />

​				

3. 例3

	``` java
	public class Test {
	    int num =5;
	    public static void main(String[] args) {
	        Test test = new Test();
	        System.out.println(test.num);
	        change(test);
	        System.out.println(test.num);
	    }
	
	    public static void change(Test test){
	        test = new Test();
	        test.num =10;
	    }
	}
	```

	和例2一样，实参test所引用的对象在堆内存中地址值的拷贝传递给了形参test。
	change(Test test)方法中的 test = new Test()相当于修改了形参test的指向，使其指向了新的Test对象，但并不会影响到实参test的指向
	此时实参test和形参test指向的并不是同一个对象，修改形参test对象的内容和实参test毫无关系
	
	<img src="https://oss.mingever.com/note/java/PassByValue3.png" style="zoom:67%;" />

​	

4. 例4

	``` java
	public class Test {
	    public static void main(String[] args) {
	        String str = "123";
	        System.out.println(str);
	        change(str);
	        System.out.println(str);
	    }
	
	    public static void change(String str){
	        str = "abc";
	    }
	}
	```

	和例3一样，String是引用类型， str = "abc"相当于改变了形参str的指向，形参指向了新的对象，但改变不了实参。这里并不是引用String不可变



## OOP

### 面对对象

**1）类**

- 一组具有相同特征和相同行为的对象的集合，不是特指的名词就是类，是一个模板，是抽象的
- 可以看成一种数据类型，是超复杂的数据类型，或叫复合，引用数据类型
- 对==类的抽象就是抽象类的属性和方法==，==属性是类的静态特征，方法是类的动态行为==
- 类是java的数据结构，封装了一组数据和对该数据的一组操作的集合，很好的体现了面对对象的封装性，将一组数据按照业务逻辑封装在一起，只提供符合业务逻辑的访问方法
- ==类内只能出现变量和方法,不能出现语句==。类内有且仅能存在的有，==成员变量；成员方法；构造器;代码块；内部类==

**2）对象**

- 对象是类的实例，特指的一件东西就是对象，是具体的
- 对象的创建：

	- Book book=new book();即生成了对象，可以使用对象名来访问对象的属性和方法
	- Book book即声明了一个引用变量，存放在栈内存中，new之后才在堆内存中根据类的属性分配对象内存空间，并自动初始化对象属性，然后根据参数类型调用构造器。返回对象的引用地址，赋值给了引用变量book，即从栈内存指向了该堆内存。（=为右结合）

	- ==创建完成对象之后，会在堆内存中自动初始化该对象中的属性，即是有默认初始值的，然后根据参数类型调用构造方法，为对象赋初值==

### 构造方法

用来描述对象的创建过程，==是用来对对象初始化的，即其意义是为对象赋值初始值==

#### 特点

- ==构造方法名和类名必须一样==
- 构造方法==不能有返回值==，且前面==不能加void==
- ==通过nwe来调用==（较特殊，即在创建对象的时候调用）

- ==创建对象时，构造方法是必须调用的，new后会自动调用构造方法，不可以显式地调用构造方法==

#### 对象实例化过程

- 在程序中使用new来生成对象时，系统会自动调用类的构造方法
- ==如果没有明确的定义构造方法，系统会自动为该类添加默认的无参数构造方法==
- ==构造方法也能重载==，多个构造方法重载时，根据生成对象时传递的参数来决定调用哪个构造方法

#### 默认构造方法

如果类中没有任何构造器，java会自动提供一个无参数的构造器，但如果用户定义了构造器，则无参构造器就不会自动提供，如果要使用，需要自己定义 。即==任何类都存在构造方法==，都可以实例化，但==接口不可以实例化，因此接口中没有构造方法。==

#### 构造方法重载

即有多个构造方法，但==构造方法中参数个数，或类型不同==

#### this

==表示对当前对象的引用，是运行期间当前对象本身==，实质是用来指当前对象的一个指针，==只能写在方法中==

1. 在**构造方法**中使用this
	- 可以出现在类的构造方法中，==代表使用该构造方法所创建的对象==
	- 用`this(参数);`调用==本类中的其他构造方法==，==只能写在构造方法的第一行==，使重载方法简化
2. 在**实例方法**中使用this
	- ==代表使用该方法的当前对象==。==实例方法中可以利用this操作成员和成员方法==，`this.成员变量;`  `this.成员方法;`
3. 区别成员变量和局部变量：==如果在方法内局部变量的命名与实例变量的命名相同，则内部屏蔽外部，实例变量在这个方法中失效==。如果想想在该方法中使用实例变量，则==需要在该变量名前加this，用来指明此变量为实例变量==。`this.变量名=变量名`（前者为实例变量，后者为局部变量）
4. ==在静态方法中不能使用this关键字，因为先有静态再有类==



### 对象中的方法

#### 依赖对象存在

在调用方法时，必须创建出方法所在类的对象，因为它依赖对象存在

#### 方法重载

体现了功能的多态，重载的方法经常互相重用

1. ==方法名一样==
2. ==参数(形参)不一样==
	- ==类型==不同
	- ==数目==不同
	- ==顺序==不同
3. ==和返回值没有关系==
4. 重载是发生在编译时的，编译器可以根据参数的类型来选择使用哪个方法

#### 方法签名

就是方法识别的关键字。==方法签名=方法名+参数类型列表==，==java类中不能存在相同签名的方法==

#### 方法中参数的传递规则

基于值的传递

java方法参数的传递只有一种方式，基于值的传递，是变量值的复制，是值的副本。基本类型就是其中值的复制，引用类型就是引用值（地址）的复制（严格来说也是复制的值，复制的是地址值，也是属于值传递，不存在址传递），即传值的方式传地址。



### 访问修饰符

是用来修饰java中类，属性，方法的访问可见范围的

1. public：公有的，在任何地方都能访问
2. protected：保护的，在类内部，同一个包，子类中能访问
3. [default]：默认的，在类内部和同一个包中可以访问（不建议用）
4. private：私有的，仅限当前内部类访问

|           | 类内 | 包内 | 子类 | 任意 |
| --------- | ---- | ---- | ---- | ---- |
| public    | ✔    | ✔    | ✔    | ✔    |
| protected | ✔    | ✔    | ✔    |      |
| [default] | ✔    | ✔    |      |      |
| private   | ✔    |      |      |      |

> - ==一个源文件中可以有多个类，但是只能有一个public类，文件名要与public类一致==，如果有其他类就只能是默认[default]修饰
>
> - 方法也可以用访问修饰符修饰，一般为private的表示只能在类内部调用，外部不可见
> - 声明属性和方法尽可能私有，这样才能做到尽可能封装
> - ==提供适当的属性访问方法，适当的开放属性的访问（get/set方法）==
> 	为了不让其示例对象直接通过 对象.属性名 来使用和修改，而是通过set属性名,get属性名，更安全，这样属性就不会随意的被赋值上任何非法的值了，可以在set属性名的方法中进行控制
>
> - ==不建议使用非公有类。即所有的类都应该是公有的==，并且一个源文件一个类



### 封装

1. 该暴漏的暴漏，该隐藏的隐藏

	- 通过private，default，protected，public实现

	- 一般将属性设为私有，再设置相应的set和get方法
	- 没有访问权限的都可以视为封装

2. 目的

	- 隐藏类的实现细节，只能通过方法访问数据，限制不合理的访问
	- 便于修改，增强代码的可维护性



### 继承

#### 继承

- 我们定义的类可以继承自某个已存在的类，这样就可以复用已经存在类的代码（属性和方法）。被继承的类叫父类，继承的类叫子类。
- 语法：`class  子类名 extends 父类名`
- 子类与父类间需要明显的is-a（什么是什么）的关系，具有一定的层次关系，特殊和一般的关系
- 子类除了==能自动继承父类中所有的非私有的属性和方法==外，还可以定义自己的属性和方法，所有子类比父类有更丰富的属性和行为（==对于父类中的private属性，子类会继承，但不可以直接访问，必须通过继承于父类的set/get方法访问==）
- 继承了成员变量和方法，但==不能继承构造方法==
- 如果没有明确声明父类，则默认父类是java.lang.Object类，因此Object类是java中所有类的直接或间接父类
- java中==只支持单继承==，一个子类只能有一个父类，但一个父类可以有很多个子类

#### 方法重写

1. ==在子类中定义和父类中同名且同参数的方法==，这种语法叫做方法的重写或覆盖

2. 需满足的条件

	- 子类方法与父类==方法同名==

	- 子类方法与父类方法==同参数==（参数的个数，类型，顺序都相同）
	- 子类方法的访问控制修饰符不能比父类方法更封闭
	- 子类方法声明抛出的异常不能比父类方法的更广泛；异常类型的个数不能比父类方法更多

3. 意义：

	  - 表示父子类都具有某种行为，但这种行为的执行方式各不相同

	  - ==是实现对象多态的基础==


4. ==方法覆盖后，用子类对象去调用该方法，执行的是覆盖后的方法==

#### 继承中的构造器

==**子类不会继承父类的构造方法；子类构造器一定调用父类构造器**==

1. ==若父类有无参的构造方法，则子类构造方法第一行默认隐式的存在super()调用父类无参构造方法==。如果子类中没有任何构造器，java会自动提供一个无参数的构造器，该无参构造器会调用父类的无参构造方法

2. ==当父类没有无参的构造方法时，子类的构造方法必须使用super(XXX)显式的调用父类的有参构造方法，即子类必须写出显式的构造方法；==
	当子类创建了对象时，子类对象可以使用父类的属性，但子类不会继承父类构造方法，所以子类构造方法要调用父类构造方法来给父类属性赋值

3. ==任何构造方法的第一行都是this(xxx)或者super(xxx)的调用，如果没有明确的调用，则系统会默认加上super()的调用==，==this(xxx)指向的构造方法也会使用super调用父类构造器，即子类构造器一定调用父类构造器。==

	> 注意：只是调用父类构造方法，而==**没有创建父类对象**==，只不过是调用父类构造方法来初始化属性。

4. 建议所有的类都提供无参数构造器，减少继承时的麻烦

5. ==JVM保证类加载是先父类后子类，父类的构造器先于子类的构造器执行来保证**成员变量的赋值顺序是先父后子**==

6. `super();`

	- ==表示调用父类中的无参构造方法==，==super指的就是父类对象==

	- ==在构造器第一行默认存在==，即==子类构造器默认调用父类无参构造器，且必须写在第一行==

	- ==有super()就不能有this()，两者互斥，只能存在一个==

	- 与this关键字类似

		1. this

			| 出现的位置                   | 代表的含义           |
			| ---------------------------- | -------------------- |
			| 构造方法的第一行/this();     | 调用本类其他构造方法 |
			| 方法代码的其他位置/this.name | 访问当前对象成员     |

		2. super

			| 出现的位置                    | 代表的含义         |
			| ----------------------------- | ------------------ |
			| 构造方法的第一行/super();     | 调用父类的构造方法 |
			| 方法代码的其他位置/super.name | 访问父类对象的成员 |

7. 子类用super()调用父类构造方法时，==super()里的参数是子类构造器的形参传过去的==

	``` java
	public class Text {
	    public static void main(String[] args) {
	        B b = new B("a",1,"b");
	    }
	}
	class A {
	    String a;
	    int b;
	    public A(String a,int b){
	        this.a = a;
	        this.b = b;
	    }
	}
	class B extends A{
	    String c;
	    public B(String a, int b,String c) {
	        super(a, b);      //子类构造方法形参来给父类构造方法传参
	        this.c=c;
	    }
	    public void fun(){
	        a=c;             //子类方法可以直接使用父类属性
	    }
	}
	```

8. 子类构造方法必定调用父类构造方法

	``` java
	public class Pet {
	    private String name;
	    public Pet(){
	        System.out.println(1);
	    }
	    public Pet(String name){
	        System.out.println(2);
	    }
	}
	
	 class Dog extends Pet{
	    public Dog(){
	        System.out.println(4);
	    }
	    public Dog(String name){
	        this();
	        System.out.println(3);
	    }
	}
	
	new Dog("棕熊"); //后输出 1 4 3
	```

	

#### 成员变量的隐藏与方法的重写

对于==属性的访问==，在==运行前就会确定==，因此只看当前的类型，当前的类型是什么就访问这个类型中定义的属性；而==对方法的调用在运行时才会确定==，要看==真实的类型==（即new的时候的类型），按照这个类型调用相应方法。==而方法内部如果访问了属性，这个属性是定义该方法的那个类型中的属性==；==方法内部如果调用了其他方法，被调用的方法仍然是这个类型中的方法==。

##### 1）成员变量的隐藏

意义不大，因为成员变量一般都是private，不会通过对象名点成员变量形式访问，而是通过get/set访问

1. 对于子类可以从父类继承的成员变量，只要子类中声明的成员变量和父类中的成员变量同名时，子类就隐藏了继承的成员变量。==父类成员变量并不是被覆盖了，而是被隐藏了==

2. 在子类中要操作这个与父类同名的成员变量时，子类操作的是子类重新声明的这个成员变量，而不是被隐藏掉的

3. 对象名点访问成员变量（`对象名.成员变量`） **==编译看左边，运行看左边==**

	1. 对象名点访问成员变量的访问范围（访问范围是编译器的概念，只需要看引用类型）（编译看左边，运行看左边）

		- 创建父类对象，用父类引用接收

			访问的范围在父类的范国(只有父类中存在的才能访问)

		- 创建子类对象，用子类引用接收

			访问的范围是==父类+子类==(自身的能够直接访问，父类的是继承过来的)

		- 创建子类对象，用父类引用接收（多态）

			访问的范围是父类的范围(只有父类中存在的才能访问)

		综上，对象名点成员变量，==它的访问范围是由引用类型来决定的==（即编译看左边，运行看左边）
		如果==引用是父类类型，那么它的访问范围只有父类；==
		而如果==引用是子类类型，那么它的访问范围是子类＋父类==

		> 在Java当中，对象名点访问成员变量的范围是编译器决定的，编译在检索成员变量时存在以下检索机制：
		>
		> 引用数据类型只能通过引用间接访问对象，而引用的声明就是为了告诉编译器引用的数据类型
		>
		> 1. 首先编译器会从==引用的数据类型的类==中去查找该成员变量，如果找到了，就直接认为他可以访问，相反如果没有找到，那么就==去父类==中找
		> 2. ==最终找到Object类==，如果==object类当中都没有该成员变量那就会编译报错==
		>
		> 在java中，==子类是知道自己有父类的==（儿子知道爸爸的存在），反之==父类不知道自己有子类==（爸爸不知道自己还有儿子）

	2. 点访问成员变量的访问结果

		- 创建父类对象，用父类引用接收

			结果是父类中的结果

		- 创建子类对象，用子类引用接收

			结果是子类中的结果

		- 创建子类对象，用父类引用接收(多态)

			结果是父类中的结果

		综合==对象名点访问成员变量的范围和结果==：
		
		==都是根据引用的数据类型来决定的，无需考虑对象==
		
		> 注意：
		>
		> 1. 父子类中的同名成员变量它们各自有各自存储的区域，父类的同名成员变量被子类同名变量隐藏了
		> 	但我们仍然可以通过父类中的get方法，或者通过super.去访问父类中同名成员变量
		> 	需要注意的是，他们都受访问权限限制
		> 2. 静态成员变量在父子类中也存在同名的情况，但它们不是覆盖也不是隐藏，而是相互独立的两个静态成员变量
		> 	但需要注意的是，如果子类继承了父类的静态成员变量，而子类自身没有，那么它们公用父类的静态成员变量

##### 2）方法重写

同子类通过重写可以覆盖已继承的实例方法，而不是隐藏

1. 重写的语法规则

	- 如果子类继承了父类的实例方法，那么子类就有权力重写这个方法
	- 方法重写是指：子类中定义一个方法，这个方法的类型和父类的方法的类型一致或是父类方法的类型的子类型，且这个方法的名字、参数的个数、参数的类型和父类的方法完全相同

2. 重写的目的

	子类通过方法的重写可以隐藏继承的方法，子类通过方法的重写可以把父类的状态和行为改变为自身的状态和行为

3. 重写后方法的调用

	- 子类创建的一个对象，如果==子类重写了父类的方法==，则==运行时系统调用的是子类重写的方法==；
	- 子类创建的一个对象，如果==子类没有重写了父类的方法==，则==运行时系统调用的是子类继承的方法==；

4. 重写的注意事项

	重写父类的方法时，不允许降低方法的访问权限，但可以提高访问权限

5. 对象名点调用成员方法（`对象名.成员方法`）**==编译看左边，运行看右边==**

	1. 对象名点调用成员方法的调用范围

		调用范围==仍然是编译概念==，这一点和对象名点访问成员变量是没有区别的

		调用范围==看引用类型==就可以了，如果==引用是父类类型，那么它的调用范围只有父类==，（==比如多态不能调用子类中特有的方法==）

		而如果==引用是子类类型==，那么它的调用范围是==子类+父类==

		同样，编译器会去父类中查找成员方法，直到找到Object, 找不到就会编译报错

	2. 对象名点调用成员方法的调用结果（==重写后==的成员方法）（编译看左边，运行看右边）

		- 创建父类对象，用父类引用接收

			体现出父类的方法行为

		- 创建子类对象，用子类引用接收

			体现出子类的方法行为

		- 创建子类对象，用父类引用接收（==多态==）

			体现出==子类的方法行为==

		综上，对象名点调用成员方法，==它的调用结果是根据对象的实际类型来决定的==
		这其实很好理解，==访问范围是编译概念，所以只需要看引用的数据类型就够了==
		但是==方法的调用必须等到程序运行时期，才能确定它的结果，需要它的实际类型(==运行时期对象的具体类型就决定了方法的调用结果)

		> 方法的覆盖：因为方法的访问结果是根据对象的具体类型决定的，所以方法在调用时，就体现为“覆盖“而不是隐藏
		>
		> 1. 注意：方法的覆盖并不是物理意义上的覆盖，只是JVM调用方法的机制导致的覆盖，仍然可以通过==super.==去访问父类的同名成员方法(受访问权限限制)
		> 2. 什么方法不能覆盖
		> 	- ==私有成员方法==，子类没有权限访问，更不能重写
		> 	- ==static方法==
		> 	- ==构造方法==，不能被继承，更不能被重写

##### 3）DEMO

1. 方法与属性混合的情况

	  - ==如果方法是从父类继承的，那么方法中使用到的属性都是父类的属性，说明父类成员变量并不是被覆盖了，而是被隐藏了==

	  ```java
	  class Father{
	      int a = 10;
	      public void fun(){
	          System.out.println(a);
	      }
	  }
	  
	  class Son extends Father{
	      int a = 20;
	  }
	  
	  new Son().fun(); //输出结果为：10
	  
	  //即使子类中已经覆盖了属性a，但是方法的行为仍然和父类一致，输出的是父类的a的值。这说明父类成员变量并不是被覆盖了，而是被隐藏了
	  //如果子类想按照代码的逻辑实现功能的话就只能重写
	  ```

	  demo1

	  ```java
	  class Father{
	      int a = 10;
	      int b = 20;
	      public void fun(){
	          System.out.println(a+" "+b);
	      }
	  
	  }
	  
	  class Son extends Father{
	      public Son(){
	          this .b = 40;
	      }
	  }
	  
	  new Son().fun(); //输出 10 40， 
	  // 相当于在Son类的构造方法更改了Father类的属性b
	  ```

	  demo2

	  ```java
	  class Father{
	      int a = 10;
	      int b = 20;
	      public void fun(){
	          System.out.println(a+" "+b);
	      }
	  
	  }
	  
	  class Son extends Father{
	      int b =30;
	      public Son(){
	          this .b = 40;
	      }
	  }
	  					
	  new Son().fun(); //输出 10 20，
	  //因为Son类覆盖了属性b，相当于在Son类的构造方法更改了Son类的属性b，而Father类的属性b依然是20
	  ```

	- 然而对于方法内部再次调用方法的情况，却正好相反。如果从父类继承来的方法A调用了方法B，并且子类重写了方法B，当子类调用方法A时，方法A内部会调用被重写的方法B。==这说明方法的重写，父类方法并不是被隐藏了，而是被覆盖了。==

		```java
		class Father{
		    public void A() {
		        B();
		    }
		    public void B() {
		        System.out.println("Origin");
		    }
		}
		
		class Son extends Father{
		    public void B() {
		        System.out.println("Override");
		    }
		}
		
		new Son().A(); //子类调用A()时会输出Override，说明方法的重写，父类方法并不是被隐藏了，而是被覆盖了。
		```


2. 子类转换为父类时，调用方法及属性的情况（多态）

	- ==当子类转换为父类后，只能调用父类中存在的方法（未重写情况下）、访问父类中存在的属性。==
		上面已经分析过，==对象名点访问成员变量的范围和结果==，==都是根据引用的数据类型来决定的，无需考虑对象==

		``` java
		class Father{
		    int a = 10;
		}
		
		class Son extends Father{
		    int a = 20;
		}
		
		Father father = new Son();
		System.out.println(father.a); //当访问属性时，属性的值是父类中的值，输出10
		```

	- 如果==方法被重写==，调用的方法就是==子类中被重写的方法==
		如果==方法没有被重写==，调用的方法就是==父类中的方法==

		``` java
		class Father{
		    public void A() {
		        System.out.println("Origin");
		    }
		}
		
		class Son extends Father{
		    public void A() {
		        System.out.println("Override");
		    }
		}
		
		Father father = new Son();
		father.A();    //因为方法被重写了，所以输出Override
		```



### 多态

#### 静态多态

即方法的多态，方法重载

#### 动态多态

即对象的多态，运行时多态

1. 一个对象可以有多种形态，即可以当作本类的对象来看，也可以当作其父类来看，即==子类实例是一种特殊的父类实例==；
	如果把一个对象当作他的父类来看，也就是==定义父类的引用得到子类对象==
2. 父类引用得到子类对象是对象多态的具体表现形式，如 Person a = new student();
	- 如果这样，就==只能使用这个变量去访问父类中所定义的成员，而不能去访问子类中特有的成员==（所以要方法重写），即访问范围是编译期的概念，只需要看引用类型，从而无法访问子类特有的成员
	- ==如果子类重写了父类的方法，再把子类对象当作父类对象来看，而去调用这个方法，那么调用的是子类重写后的方法==，
		==但不能用父类对象去调用子类自己特有的方法==，和上面一样，访问范围是编译期的概念

#### 必要条件

1. 继承
2. 重写
3. 向上转型（父类引用指向子类对象）

#### 成员访问的特点

1. 关于成员变量：编译看左边，运行看左边
2. 关于成员方法（静态）：编译看左边，运行看左边
3. 关于成员方法（非静态）：==编译看左边，运行看右边！ 即编译时类型由声明类型决定，运行时类型由赋值对象的类型决定==

#### 优缺点

把不同子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用代码，做出通用编辑。即提高了代码的扩展性与维护性

但是不能使用子类的特有功能了

#### 引用类型的转换

类似基本类型的转换，只能发生在父子类之间

1. ==向下转型==（隐式/自动类型转换），是小类型到大类型

	子类可以自动转换成父类的对象，如 Person p = nw Student(); （即多态）

2. ==向上转型==（强制类型转换），是大类型到小类型

	- 父类对象不能使用子类中特有的功能，要使用只能向上转型（即==将父类引用强制转换为子类的引用==）
	- 格式：子类名 新对象 = （子类名）旧对象 ，向上转型的前提是必须有向下转型
	- ==不具备继承关系的两个引用变量是不能强制类型转换的==，否则会出现异常。可以先用`instanceof`关键字进行检查引用对象的类型



### 接口

#### 抽象类

抽象类是一种特殊的数据类型，抽象类是类的进一步抽象，抽象类用来==捕捉子类的通用特性==

==抽象类一般都要被继承，抽象类里可以有抽象方法也可以有一般方法，继承抽象类的实现类必须实现抽象类中所有的抽象方法==

1. 用法

	- class前加``abstract``关键字修饰类，变为抽象类
	- 用abstract修饰方法，变为抽象方法，==抽象方法没有方法体==；
	- ==定义子类实现抽象类==，用``extends``继承，实现抽象类中所有的方法

2. 抽象方法

	- 抽象类都会包含抽象方法

	- abstract修饰的方法，==抽象方法没有方法体==
	- 包含抽象方法的类，一定是抽象类

3. ==抽象类只能被继承，子类需要去实现抽象类中的抽象方法==

4. ==抽象类不能实例化，但可以定义引用来得到子类对象==。

5. ==抽象类中可以有构造方法==，它的派生类在实例化调用构造函数的时候会先调用基类中的构造函数。即==只要是类就有构造方法==

6. ==抽象类中可以有一般方法==，也可以有抽象方法；==**抽象类中已经实现的方法是为了代码复用(接口中可以用默认方法)；待实现的方法是为了限制子类的功能**==



#### 接口

接口是一个类，是一种==特殊的抽象类==，更加纯粹（其只有静态常量和抽象方法），即==接口是抽象方法和静态常量定义的集合==

==接口不可以实例化，但接口对象可以指向它的实现类对象==

**1）接口的用法**

1. 编写接口

	``` java
	interface 接口名称 {
		静态常量;
		抽象方法;
	}
	```

2. 实现接口

	用关键字`implements`，要实现多个接口中间要用逗号隔开

3. 使用接口

	==实现接口中所有的抽象方法==

**2）接口的特征**

- ==接口中所有的方法都是抽象方法，方法默认为`public abstract`，因此abstract可以省略==
- ==接口中所有的属性都是静态常，变量默认为`public static final`，因此static final可以省略==
- ==接口没有构造方法==
- ==一个类可以实现多个接口==，即使用==接口可以弥补单继承的缺陷==
- ==接口不能实例化==，但==可以定义引用来得到实现类的对象，即接口的多态==。
- ==接口与接口直接可以继承，且可以多继承==。==接口不能继承类，接口与类之间是实现关系==，即类实现接口

**3）接口的意义**

- 是一种==功能的扩展==，==表示一种能力==（has a）
- 表示一种约束，一种规范
- ==方法的描述说明和方法的功能分开==，降低程序的复杂性，使其灵活，便于扩充修改
- 弥补了单继承的缺陷（类似与多继承）
- 降低了系统的耦合性

**4）默认方法**

默认方法就是==接口可以有实现方法，而且不需要实现类去实现其方法==，==只需在方法名前面加个 `default` 关键字即可实现默认方法==

- 语法

	``` java
	public interface Vehicle {
	   default void print(){
	      System.out.println("我是一辆车!");
	   }
	}
	```

- 实现类可以重写接口里的静态方法

- 实现类可以通过 `接口名.super.默认方法名` 来==调用指定接口的默认方法==

**5）接口静态方法**

接口可以声明（并且可以提供实现）静态方法

``` java
public interface Vehicle {
    //默认方法
   default void print(){
      System.out.println("我是一辆车!");
   }
    // 静态方法
   static void blowHorn(){
      System.out.println("按喇叭!!!");
   }
}
```

**6）面向接口编程**

- 如，Icon img = new     ImageIcon()接口类型的引用指向了一个实现该接口的对象，这是java中的一种多态现象，接口的多态
- java中接口不可以实例化，但可以通过接口引用指向一个对象，这样通过接口来调用方法可以屏蔽掉具体的方法实现，java中经常遇到的接口回调，即我们所说的面向接口的编程

#### 抽象类和接口的区别

- 接口不能有构造方法；抽象类中可以有，且默认存在无参构造方法，也可以显式的写出，用来被子类调用。即抽象类必定存在构造方法
- 抽象类中不一定包含抽象方法，包含抽象方法的类一定是抽象类
- 接口中的方法都是抽象方法，方法默认为public abstract；抽象类可以有非抽象方法，也可以有静态方法
- 接口中所有的属性都是静态常量，变量默认为public static final；抽象类中没有要求
- 抽象类是一个类，别的类用extends来继承下来，并扩展，有非常强的is-a关系
- 接口只是定义功能和行为的规范，没有is-a的关系。别的类只是用implements来实现这个接口，实现接口定义的方法；接口是一种规范，被调用时，主要关注里面的方法，而方法是不需要初始化的，因此接口不需要构造方法；且类可以实现多个接口，若接口有构造器则不好决定调用顺序
- 继承抽象类是为了使用这个类的属性和行为，而实现接口是为了使用它规范的某一个行为。即==**接口为了规范，抽象为了复用**==

#### 抽象类实现接口

抽象类作用：==降低接口实现类对接口实现过程难度，将接口中不需要使用的抽象方法交给抽象类进行完成，这样接口实现类只需要对接口中需要的方法进行重写（可以说抽象类就这一个功能）==

一般来说我们使用普通类来实现接口，这个普通类就必须实现接口中所有的方法，这样的结果就是普通类中就需要实现多余的方法，造成代码冗余。但是如果我们使用的是抽象类来实现接口，那么就可以只实现接口中的部分方法，并且当其他类继承这个抽象类时，仍然可以实现接口中有但抽象类并未实现的方法。

这就是抽象工厂模式。好处就是，假设接口定义了10多个方法，但是好多方法的实现都是固定不变的，唯独有那么一两个需要实现类写出单独的逻辑，这种情况就很恶心，如果直接实现这个接口，好多方法就得复制一遍，造成代码冗余。所以，我们先使用一个抽象类实现这个接口。我们需要注意，抽象类可以实现接口的所有方法，也可以一个都不实现。

``` java
接口
interface A{
    public void a();
    public void b();
    public void c();
}
抽象类
abstract class B implements A{
    public void a(){}
    public void b(){}
}
具体实现类
public C class cextends B{
    public void a(){}
    public void b(){}
    public void C(){}

}
```



### final

#### 修饰类

- ==用fianl修饰的类不能再被继承==。即不能有子类，不能使用CGLIB动态代理

- ==String==是final类，不能被继承
- ==Math==是final类
- Integer,Long.Character等==包装类==是final类

#### 修饰方法

修饰的方法==不能再被重写==（原则是不允许使用final方法）

#### 修饰变量

1. 可以修饰局部变量
2. 修饰形参
3. 修饰成员变量

#### final static

- ==final static 修饰的变量作为常量==

- 一般要求==常量名都是大写字母==



### static

可以修饰属性，方法，内部类，代码块

s==tatic修饰的资源属于类级别，是全体对象实例共享的资源==

==静态成员属于类，非静态成员属于对象，即静态方法可以不创建对象就可以使用，非静态方法必须有了类的实例后才可以调用。==

在JDBC中，Connection，PreparedStatement，ResultSet以及数据库的连接、关闭方法要使用静态



#### 修饰属性

1. 为==全局属性==，==多个对象同一个内存空间==
2. ==使用static修饰的属性，属于类的全体类的实例共享变量==，静态属性==是在类的加载期间初始化的==
3. 访问方式：使用 `类名.属性` 访问，如System.out，==而实例变量是属于对象的属性==



#### 修饰方法

即==类方法==

- 使用static修饰的方法，属于类的方法，==一般用来表示工具方法==
- ==在类加载以后就可以自己调用==，不需要创建任何类的实例对象
- ==static先存在，对象后存在==。static是在类的加载期间初始化的，因此==里面不能用this，也不能调用其他对象，因为使用方法时没有对象==
- ==静态只能调用静态；普通可以调用普通，也可以调用静态==。
	即静态方法不能访问属于对象的资源（实例变量，实例方法）
	静态方法不能调用非静态方法，只能调用静态方法。是因为非静态方法中的对象可能还未创建，静态先存在，对象后存在。
	==静态方法要调用非静态方法或非静态属性时，只能先实例化对象，然后用对象去调用非静态方法或非静态属性==
- 调用静态方法
	- `静态方法名();`  只能在本类中这样使用，直接调用本类的静态方法
	- `类名.静态方法名();`  正规调用方法，可以调用其他类的静态方法
- ==main方法是静态方法==
	- 即如果在主方法中直接调用自定义方法，该方法需要关键字static修饰
	- 要==调用非静态方法时，要先实例化对象==，然后==用对象调用非静态方法==

#### 静态代码块

不常用，很少见

是在类的加载期间运行的代码块，由于类只加载一次，所以静态代码块只执行一次。非常少见

``` java
static{
    代码块
}
```



### 内部类

java允许将一个类定义在另一个类的内部，这种语法叫做内部类

#### 成员内部类

- 每一个成员内部类对象都对应一个外部类对象；一个外部类对象可以有多个内部类对象
- 在成员内部类里可以访问外部类私有属性和方法

#### 静态内部类

- 作为外部类的类成员存在
- 修饰符和成员内部类一样
- 静态内部类里不能访问外部类的非静态成员，只能访问静态成员
- 声明：外部类名.内部类名
- 实例化：new 外部类名.内部类构造函数();
- 静态内部类里可以定义静态成员

#### 局部内部类

- 在方法中定义甚至在方法快中定义；不能访问控制修饰符
- 局部内部类只能访问final类型的局部变量

#### 匿名内部类

最常用，使用最多，匿名内部类也就是没有名字的内部类，正因为没有名字，所以匿名内部类只能使用一次

- 语法

	``` java
	new 父类构造器(实参列表)|抽象类()|实现接口(){
	    匿名内部类的类体部分
	}
	```

- ==没有类名，没有构造方法==

- 适合创建那种只需要一次使用的类，{}后要有 `;` 分号

- ==匿名内部类必须继承一个父类，或实现一个接口，但最多只能继承一个父类，或实现一个接口。且必须实现接口中的所有抽象方法==

- ==匿名内部类不能定义静态成员与方法，其中的方法也不能是抽象的==

	demo1

	``` java
	//不使用匿名内部类来实现抽象方法
	abstract class Person {
	    public abstract void eat();
	}
	 
	class Child extends Person {
	    public void eat() {
	        System.out.println("eat something");
	    }
	}
	 
	public class Demo {
	    public static void main(String[] args) {
	        Person p = new Child();
	        p.eat();
	    }
	}
	//我们用Child继承了Person类，然后实现了Child的一个实例，将其向上转型为Person类的引用，但是，如果此处的Child类只使用一次，那么将其编写为独立的一个类是很麻烦的
	
	//使用匿名内部类
	abstract class Person {
	    public abstract void eat();
	}
	 
	public class Demo {
	    public static void main(String[] args) {
	        Person p = new Person() {
	            public void eat() {
	                System.out.println("eat something");
	            }
	        };
	        p.eat();
	    }
	}
	//直接将抽象类Person中的方法在大括号中实现了，这样便可以省略一个类的书写。此处相当于，父类指向了子类引用，p是父类类型，所以无法访问内部类自己定义的新方法。
	
	new Person() {
	    public void eat() {
	        System.out.println("eat something");
	    }
	}.eat();
	//此处相当于直接new了一个子类，在{}里可以重写父类方法、实现接口、定义自己新的方法。{}后可以直接调用子类方法，或调用继承的父类方法，或调用子类重写的父类方法。{}后要有分号 ";""
	
	//并且，匿名内部类还能用于接口上
	interface Person {
	    public void eat();
	}
	 
	public class Demo {
	    public static void main(String[] args) {
	        Person p = new Person() {
	            public void eat() {
	                System.out.println("eat something");
	            }
	        };
	        p.eat();
	    }
	}
	
	//由上面的例子可以看出，只要继承一个父类或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现
	//最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口
	public class Demo {
	    public static void main(String[] args) {
	        Thread t = new Thread() {
	            public void run() {
	                for (int i = 1; i <= 5; i++) {
	                    System.out.print(i + " ");
	                }
	            }
	        };
	        t.start();
	    }
	}
	
	public class Demo {
	    public static void main(String[] args) {
	        Runnable r = new Runnable() {
	            public void run() {
	                for (int i = 1; i <= 5; i++) {
	                    System.out.print(i + " ");
	                }
	            }
	        };
	        Thread t = new Thread(r);
	        t.start();
	    }
	}
	```

	demo3

	``` java
	interface Product
	{
	   public double getPrice();
	   public String getName();
	}
	public class AnonymousTest
	{
	   public void test(Product p)
	   {
	      System.out.println("购买了一个" + p.getName()
	         + "，花掉了" + p.getPrice());
	   }
	   public static void main(String[] args)
	   {
	      AnonymousTest ta = new AnonymousTest();
	      // 调用test()方法时，需要传入一个Product参数，
	      // 此处传入其匿名内部类的实例
	      ta.test(new Product()
	      {
	         public double getPrice()
	         {
	            return 567.8;
	         }
	         public String getName()
	         {
	            return "AGP显卡";
	         }
	      });
	   }
	}



